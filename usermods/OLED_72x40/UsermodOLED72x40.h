#pragma once

#include "wled.h"
#include <U8g2lib.h>
#include <Wire.h>

#define OLED_SDA 5
#define OLED_SCL 6
#define LED_PIN  8

// 128x40 bitmap generated by LCD Matrix Studio
const unsigned char akemi_logo [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xC0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x07, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x7E, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x3C, 0x60, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1C, 0x18, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x1C, 0x18, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x18, 0x20, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1E, 0x3C, 0x60, 0x00, 0x38, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xE0, 0x00, 0x0C, 0x00, 0x80, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xE0, 0x00,
  0x02, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1F, 0xC3, 0xE0, 0x00, 0x01, 0x00, 0x43, 0xC3, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x1F, 0xE7, 0xE0, 0x00, 0x01, 0x02, 0x46, 0x43,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xE0, 0x00,
  0x01, 0x02, 0x44, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0x1F, 0xFF, 0xE0, 0x01, 0x01, 0x02, 0x45, 0xC9, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x38, 0x1F, 0xFF, 0xE0, 0x1C, 0x01, 0x32, 0x47, 0x09,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x10,
  0x01, 0x12, 0x42, 0x0D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
  0x30, 0x00, 0x00, 0x30, 0x01, 0xD2, 0x4B, 0x07, 0xE0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0C, 0x2E, 0xE7, 0x70, 0x30, 0x00, 0xDE, 0x79, 0xE0,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0xE7, 0x60, 0x60,
  0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
  0x06, 0xC6, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x08, 0xC6, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0xC6, 0x08, 0xC0,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0xE0, 0xC6, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xE0, 0xC6, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};


class UsermodOLED72x40 : public Usermod {
  private:
    U8G2_SSD1306_128X64_NONAME_F_HW_I2C* u8g2 = nullptr;
    bool enabled = true, initDone = false, displayOff = false;
    unsigned long lastUpdate = 0, lastInteraction = 0;
    unsigned long screenTimeoutMS = 60000;
    int xOff = 28, yOff = 24;
    byte vValues[72];
    bool flipDisplay = false;

  public:
    void setup() {
      pinMode(LED_PIN, OUTPUT);
      Wire.begin(OLED_SDA, OLED_SCL);
      WiFi.setTxPower(WIFI_POWER_8_5dBm);
      // Wire.setClock(100000); // Set to 100kHz (Standard Mode) to avoid frequent connection issues
      u8g2 = new U8G2_SSD1306_128X64_NONAME_F_HW_I2C(U8G2_R0, U8X8_PIN_NONE);
      
      if (u8g2->begin()) {
        u8g2->setContrast(255);
        u8g2->setFlipMode(flipDisplay ? 1 : 0);
        memset(vValues, 0, sizeof(vValues));
        u8g2->clearBuffer();

        // FIXED X-OFFSET FOR SPLASH
        // Since akemi_logo is 128px wide (16 bytes), we don't shift X.
        // We only shift Y to align the 40px height within the 64px buffer.
        int splashX = 0; 
        int splashY = flipDisplay ? (64 - 40 - yOff) : yOff;

        // Draw the 128x40 bitmap
        u8g2->drawBitmap(splashX, splashY, 16, 40, akemi_logo);
        
        // The IP address/mDNS text still needs the relative shift to stay 
        // centered under the logo area
        int textX = flipDisplay ? (128 - 72 - xOff) : xOff;
        
        u8g2->setFont(u8g2_font_4x6_tf);
        u8g2->setCursor(textX + 12, splashY + 38);
        
        if (Network.isConnected()) u8g2->print(Network.localIP()); 
        else u8g2->print(cmDNS);
        
        u8g2->sendBuffer();
        delay(5000); 
        lastInteraction = millis();
        initDone = true;
      }
    }

    void loop() {
      // 1. LED HEARTBEAT (Always runs)
      static unsigned long ledTimer = 0;
      if (!Network.isConnected()) {
        if (millis() - ledTimer > 200) { ledTimer = millis(); digitalWrite(LED_PIN, !digitalRead(LED_PIN)); }
      } else {
        float pulse = (sin(millis() / 2000.0 * PI) + 1) * 127.5;
        analogWrite(LED_PIN, (int)pulse);
      }

      if (!enabled || !initDone) return;

      // 2. TIMEOUT LOGIC (Moved before the strip updating guard)
      if (screenTimeoutMS > 0 && (millis() - lastInteraction > screenTimeoutMS)) {
        if (!displayOff) { u8g2->setPowerSave(1); displayOff = true; }
        return; 
      }

      // 3. DRAWING LOGIC (Bypassed if screen is blanked)
      if (strip.isUpdating()) return;

      if (millis() - lastUpdate > 100) {
          lastUpdate = millis();
          if (displayOff) { u8g2->setPowerSave(0); displayOff = false; }

          u8g2->clearBuffer();
          
          // ADJUST OFFSETS BASED ON FLIP
          // Normal: xOff=28, yOff=24
          // Flipped: We need to shift the content to the opposite side of the 128x64 buffer
          int currentX = flipDisplay ? (128 - 72 - xOff) : xOff;
          int currentY = flipDisplay ? (64 - 40 - yOff) : yOff;

          u8g2->setFont(u8g2_font_5x7_tf);
          char lineBuffer[17];
          extractModeName(effectCurrent, JSON_mode_names, lineBuffer, 16);
          u8g2->drawStr(currentX, currentY + 7, lineBuffer);
          u8g2->drawHLine(currentX, currentY + 9, 72);

          for (int i = 0; i < 71; i++) vValues[i] = vValues[i+1];
          vValues[71] = map(bri, 0, 255, 0, 15);
          for (int i = 0; i < 71; i++) {
              u8g2->drawLine(currentX + i, currentY + 26, currentX + i, currentY + 26 - vValues[i]);
          }

          u8g2->setFont(u8g2_font_4x6_tf);
          u8g2->setCursor(currentX, currentY + 38);
          u8g2->print("S:"); u8g2->print(map(effectSpeed, 0, 255, 0, 99)); u8g2->print("% ");
          u8g2->print("I:"); u8g2->print(map(effectIntensity, 0, 255, 0, 99)); u8g2->print("% ");
          u8g2->print("B:"); u8g2->print(map(bri, 0, 255, 0, 100)); u8g2->print("%");
          
          u8g2->sendBuffer();
      }
    }

    void onStateChange(uint8_t mode) {
      lastInteraction = millis();
      lastUpdate = 0; 
      if (displayOff && u8g2) { u8g2->setPowerSave(0); displayOff = false; }
    }

    bool handleButton(uint8_t b) {
      lastInteraction = millis();
      if (displayOff && u8g2) { u8g2->setPowerSave(0); displayOff = false; }
      return false; 
    }

    void appendConfigData(JsonArray &config) {
      JsonObject top = config.createNestedObject();
      top[F("usermod")] = F("OLED_72x40");

      // This creates the UI elements in the Usermod settings page
      config.createNestedObject()[F("OLED_72x40:enabled")];
      config.createNestedObject()[F("OLED_72x40:flipDisplay")];
      config.createNestedObject()[F("OLED_72x40:x-offset")];
      config.createNestedObject()[F("OLED_72x40:y-offset")];
      config.createNestedObject()[F("OLED_72x40:sleepTimeout")];
      config.createNestedObject()[F("OLED_72x40:bootButtonPin")];
    }
    void addToConfig(JsonObject& root) {
      JsonObject top = root.createNestedObject(F("OLED_72x40"));
      top[F("enabled")] = enabled;
      top[F("flipDisplay")] = flipDisplay; // Registration for UI
      top["bootButtonPin"] = 9;
      top["x-offset"] = xOff;
      top["y-offset"] = yOff;
      top["sleepTimeout"] = screenTimeoutMS / 1000;
    }

   bool readFromConfig(JsonObject& root) {
      JsonObject top = root[F("OLED_72x40")];
      if (top.isNull()) return false;

      enabled = top[F("enabled")] | enabled;
      flipDisplay = top[F("flipDisplay")] | flipDisplay;
      xOff = top[F("x-offset")] | 28; 
      yOff = top[F("y-offset")] | 24;
      
      // Guard against 0 or negative timeout values
      unsigned long timeoutSec = top[F("sleepTimeout")] | 60;
      screenTimeoutMS = timeoutSec * 1000;

      if (initDone && u8g2) u8g2->setFlipMode(flipDisplay ? 1 : 0);

      // Apply the button pin 9 default logic
      int pin = top[F("bootButtonPin")] | 9;
      if (btnPin[0] == -1 || btnPin[0] != pin) {
        btnPin[0] = pin;
        buttonType[0] = BTN_TYPE_PUSH;
      }
      return true;
    }

    uint16_t getId() { return USERMOD_ID_OLED_72x40; }
};