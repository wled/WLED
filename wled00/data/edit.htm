<!DOCTYPE html>
<html lang="en">
<head>
<title>WLED File Editor</title>
<meta name="author" content="DedeHai, based on editor by Me-No-Dev">
<meta name="Description" content="ESP File Web Editor">
<link rel="shortcut icon" href="favicon.ico">
<link href="style.css" rel="stylesheet">
<!-- Optional lightweight JSON editor - fallback to textarea if CDN is unavailable -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.4/ace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.4/mode-json.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.4/theme-monokai.min.js"></script>
<script src="common.js"></script>
<style>
/* Editor-specific styles */
#top {
	display: flex;
	align-items: center;
	gap: 8px;
	background: #222;
	padding: 6px 10px;
}
#top .center {
	flex: 1;
	text-align: center;
}
#top .right {
	margin-left: auto;
}
#top input[type="text"] {
	background: #555;
	color: #fff;
	border: 2px solid #555;
	padding: 6px 8px;
	min-width: 200px;
}
#tree {
	position: absolute;
	top: 66px;
	left: 0;
	bottom: 0;
	width: 200px;
	background: #222;
	overflow-y: auto;
	padding: 8px;
	padding-bottom: 100px;  /* extra space so context menu always fits */
	text-align: left;
}
#editor, #preview {
	position: absolute;
	top: 66px;
	left: 200px;
	right: 0;
	bottom: 0;
	background: #333;
}
#editor {
	display: flex;
	flex-direction: column;
}
#editor textarea {
	flex: 1;
	background: #333;
	color: #fff;
	border: 2px solid #333;
	padding: 8px;
	font: 13px monospace;
	resize: none;
	outline: none;
}
#ace-editor {
	flex: 1;
}
#preview {
	display: none;
	padding: 10px;
	text-align: center;
}
#preview img {
	image-rendering: pixelated;
	width: 40%;
	height: auto;
}
#loader {
	position: fixed;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	display: none;
}
.loader {
	width: 60px;
	height: 60px;
	border: 6px solid #444;
	border-top-color: #28f;
	border-radius: 50%;
	animation: spin 1s linear infinite;
}
/* Ace editor colors to match WLED style*/
.ace-monokai .ace_string { color: #4c4 !important; }
.ace-monokai .ace_constant.ace_numeric { color: #fa0 !important; }
.ace-monokai .ace_constant.ace_language { color: #f84 !important; }
.ace-monokai .ace_variable { color: #28f !important; }
.ace_editor { font: 13px monospace !important; }
@keyframes spin { to { transform: rotate(360deg); } }
</style>
<script>
var QueuedRequester = function(){ this.q=[]; this.r=false; this.x=null; }
QueuedRequester.prototype = {
	_request: function(req){
		this.r = true;
		var that = this;
		function cb(x,d){ return function(){
			if (x.readyState==4){
				gId("loader").style.display="none";
				d.callback(x.status,x.responseText);
				if (that.q.length===0) that.r=false;
				if (that.r) that._request(that.q.shift());
			}
		}}
		gId("loader").style.display="block";
		var p="";
		if (req.params instanceof FormData) p=req.params;
		else if (req.params instanceof Object){
			for(var key in req.params){
				p+=(p===""?(req.method==="GET"?"?":""):"&")+encodeURIComponent(key)+"="+encodeURIComponent(req.params[key]);
			}
		}
		this.x=new XMLHttpRequest();
		this.x.onreadystatechange=cb(this.x,req);
		if (req.method==="GET"){ 
			this.x.open(req.method, req.url+p, true);
			this.x.send();
		}
		else{ 
			this.x.open(req.method, req.url, true);
			if (typeof p === "string") this.x.setRequestHeader("Content-type","application/x-www-form-urlencoded");
			this.x.send(p);
		}
	},
	add: function(method,url,params,cb){
		this.q.push({url:url,method:method,params:params,callback:cb});
		if (!this.r) this._request(this.q.shift());
	}
};
var req=new QueuedRequester();

function loadPreview(filename, editor) {
	var pathField = gId("filepath");
	pathField.value = filename;
	if (/\.(png|jpg|jpeg|gif|bmp|webp)$/i.test(filename)) {
		gId("editor").style.display="none";
		gId("preview").style.display="block";
		gId("preview").innerHTML = '<img src="/edit?func=edit&path=' + encodeURIComponent(filename) + '&_cb=' + Date.now() + '">';
	} else {
		editor.loadText(filename);
	}
}

function createTop(element, tree, editor){
	// Create hidden file input
	var input = cE("input");
	input.type = "file";
	input.style.display = "none"; // Hide the default file input

	// Create container structure
	var leftDiv = cE("div");
	leftDiv.className = "left";
	var centerDiv = cE("div");
	centerDiv.className = "center";
	var rightDiv = cE("div");
	rightDiv.className = "right";

	// Single text field for filename
	var path = cE("input");
	path.id = "filepath";
	path.type = "text";

	var uploadBtn = cE("button"); uploadBtn.className = "sml"; uploadBtn.innerHTML = "Upload File";
	var clearBtn = cE("button"); clearBtn.className = "sml"; clearBtn.innerHTML = "Clear";
	var saveBtn = cE("button"); saveBtn.className = "sml"; saveBtn.innerHTML = "Save";
	var backBtn = cE("button"); backBtn.className = "sml"; backBtn.innerHTML = "Back to controls"; backBtn.onclick = function(){ window.location.href = getURL("/"); };

	// Add elements to Top
	leftDiv.appendChild(path);
	leftDiv.appendChild(clearBtn);
	leftDiv.appendChild(saveBtn);
	centerDiv.appendChild(backBtn);
	rightDiv.appendChild(uploadBtn);
	gId(element).appendChild(input);
	gId(element).appendChild(leftDiv);
	gId(element).appendChild(centerDiv);
	gId(element).appendChild(rightDiv);
	editor.clearEditor();

	uploadBtn.onclick = function() {
		input.click(); // invokes file selector
	};

	function httpPostCb(st,resp){
		if (st!=200) alert("ERROR "+st+": "+resp);
		else {
			alert("Upload successful!");
			tree.refreshPath("/");
		}
	}

	// Clear button - clears the editor
	clearBtn.onclick = function(){
		editor.clearEditor(); // Clear editor, file will be created on save
		input.value = ""; // Clear the file selection
	};

	saveBtn.onclick = function(){ editor.save(); };

	// Handle file selection and upload
	input.onchange = function(){
		if (input.files.length == 0) return;
		var file = input.files[0];
		var fd = new FormData();
		fd.append("file", file, file.name);
		console.log("Uploading:", file.name);
		req.add("POST", "/upload", fd, function(st, resp) {
			httpPostCb(st, resp);
			if(st == 200) { loadPreview(file.name, editor); }
		});
		input.value = ""; // Clear the file selection
	};
}

function createTree(element, editor){
	var treeRoot=cE("div");
	gId(element).appendChild(treeRoot);

	function downlFile(p){
		window.open("/edit?func=download&path=" + encodeURIComponent(p), "_blank");
	}

	function delFile(p, tree) {
		if (!confirm("Delete " + p + "?")) return;
		req.add("GET", "/edit", { func:"delete", path:p }, function(st, resp) {
			if (st != 200) alert("ERROR " + st + ": " + resp);
			else tree.refreshPath("/");
		});
	}

	function createLeaf(path,name){
		var leaf=cE("div");
		leaf.style.cssText="cursor:pointer;padding:2px 4px;border-radius:2px;position:relative";
		leaf.textContent=name;
		leaf.onmouseover=function(){ leaf.style.background="#333"; };
		leaf.onmouseout=function(){ leaf.style.background=""; };
		leaf.onclick=function(){ loadPreview(name, editor); };

		// Right-click context menu
		leaf.oncontextmenu = function(e) {
			e.preventDefault();
			var existingMenu = gId("context-menu");
			if (existingMenu) existingMenu.remove();

			var menu = cE("div");
			menu.id = "context-menu";
			menu.style.cssText = "position:fixed;left:"+e.clientX+"px;top:"+e.clientY+"px;background:#333;border:1px solid #666;border-radius:4px;z-index:1000;box-shadow:2px 2px 8px rgba(0,0,0,0.5)";

			// Download option
			var downloadOption = cE("div");
			downloadOption.textContent = "Download";
			downloadOption.style.cssText = "padding:8px 12px;cursor:pointer;color:#fff";
			downloadOption.onmouseover = function() { this.style.background = "#555"; };
			downloadOption.onmouseout = function() { this.style.background = ""; };
			downloadOption.onclick = function() { downlFile(path); menu.remove(); };

			// Delete option
			var deleteOption = cE("div");
			deleteOption.textContent = "Delete";
			deleteOption.style.cssText = "padding:8px 12px;cursor:pointer;color:#ff6666";
			deleteOption.onmouseover = function() { this.style.background = "#555"; };
			deleteOption.onmouseout = function() { this.style.background = ""; };
			deleteOption.onclick = function() { delFile(path, {refreshPath: function() { treeRoot.innerHTML=""; httpGet("/"); }}); menu.remove(); };

			menu.appendChild(downloadOption);
			menu.appendChild(deleteOption);
			d.body.appendChild(menu);

			// Remove menu when clicking elsewhere
			setTimeout(function() {
				d.onclick = function() {
					if (menu.parentNode) menu.remove();
					d.onclick = null;
				};
			}, 100);
		};

		treeRoot.appendChild(leaf);
	}

	function addList(path,items){
		for(var i=0;i<items.length;i++){
			if (items[i].type==="file" && items[i].name !== "wsec.json") { // hide wsec.json, this is redundant on purpose (done in C code too), just in case...
				var fullPath = path === "/" ? "/" + items[i].name : path + "/" + items[i].name;
				createLeaf(fullPath, items[i].name);
			}
		}
	}

	function getCb(p){
		return function(st,resp){
			if (st==200) {
				try {
					addList(p, JSON.parse(resp));
				} catch(e) {
					console.error("Failed to parse file list:", e);
				}
			} else {
				console.error("Failed to load file list:", st, resp);
			}
		};
	}

	function httpGet(p){
		req.add("GET", "/edit", { func:"list", path:p }, getCb(p));
	}

	this.refreshPath=function(p){
		treeRoot.innerHTML="";
		httpGet("/");
	};

	httpGet("/");
	return this;
}

// Pretty-print ledmapX.json: print 2D maps in aligned columns, print 1D maps as single line
function prettyLedmap(json){
	try {
		let obj = JSON.parse(json);
		if (!obj.map || !Array.isArray(obj.map)) return JSON.stringify(obj, null, 2);
		let width = obj.width || obj.map.length;
		let maxLen = Math.max(...obj.map.map(n => String(n).length)); // max length of numbers for padding

		function pad(num) {
			let s = String(num);
			while (s.length < maxLen) s = " " + s;
			return s;
		}

		let rows = [];
		for (let i = 0; i < obj.map.length; i += width) {
			rows.push("    " + obj.map.slice(i, i + width).map(pad).join(", "));
		}

		let pretty = "{\n  \"map\": [\n" + rows.join(",\n") + "\n  ]";
		for (let k of Object.keys(obj)) {
			if (k !== "map") {
				pretty += ",\n  \"" + k + "\": " + JSON.stringify(obj[k]);
			}
		}
		pretty += "\n}";
		return pretty;
	} catch (e) {
		return json;
	}
}

function createEditor(element,file){
	if (!file) file="";

	var ta = cE("textarea");
	var editorDiv = cE("div");
	editorDiv.id = "ace-editor";
	editorDiv.style.display = "none";

	gId(element).appendChild(ta);
	gId(element).appendChild(editorDiv);

	var currentFile = file;
	var aceEditor = null;
	var useAce = false;

	function updateEditorMode() {
		if (!useAce || !aceEditor) return;

		// Check filename from text field or current file
		var pathField = gId("filepath");
		var filename = (pathField && pathField.value) ? pathField.value : currentFile;

		if (filename && filename.toLowerCase().endsWith('.json')) {
			aceEditor.session.setMode("ace/mode/json");
		} else {
			aceEditor.session.setMode("ace/mode/text");
		}
	}

	// Try to initialize Ace editor if available
	function initAce(){
		if (useAce || typeof ace === 'undefined') return;
		try {
			aceEditor = ace.edit(editorDiv);
			aceEditor.setTheme("ace/theme/monokai");
			aceEditor.session.setMode("ace/mode/text");
			aceEditor.setOptions({ fontSize:"13px", fontFamily:"monospace", showPrintMargin:false, wrap:true });
			useAce = true;
			//console.log("Use Ace editor");
			switchToAce();
			updateEditorMode();

			// Monitor filename input for JSON highlighting (prevent duplicate listeners)
			var pathField = gId("filepath");
			if (pathField && !pathField.hasJsonListener) {
				pathField.oninput = function() {
					updateEditorMode();
				};
				pathField.hasJsonListener = true;
			}
		} catch(e) {
			//console.log("Ace load failed:", e);
			useAce = false;
		}
	}
	// Try now and on window load as a fallback
	setTimeout(initAce, 100);
	window.addEventListener('load', initAce);

	function switchToAce() {
		if (useAce && aceEditor) {
			ta.style.display = "none";
			editorDiv.style.display = "block";
			editorDiv.style.flex = "1";
			aceEditor.setValue(ta.value, -1);
			aceEditor.resize();
		}
	}

	function getCurrentContent() {
		if (useAce && aceEditor && editorDiv.style.display !== "none") {
			return aceEditor.getValue();
		}
		return ta.value;
	}

	function setCurrentContent(content) {
		ta.value = content;
		if (useAce && aceEditor) {
			aceEditor.setValue(content, -1);
		}
	}

	// Live JSON validation for textarea
	ta.oninput = function() {
		var pathField = gId("filepath");
		var filename = pathField ? pathField.value : currentFile;

		if (filename && filename.toLowerCase().endsWith('.json')) {
			try {
				JSON.parse(ta.value);
				ta.style.border = "2px solid #333"; // Valid JSON - normal border
			} catch(e) {
				ta.style.border = "2px solid #f00"; // Invalid JSON - red border
			}
		} else {
			ta.style.border = "2px solid #333"; // Normal border for non-JSON
		}
	};

	function httpPost(filename,data){
		var finalData = data;
		// Minify JSON files before upload
		if (filename.toLowerCase().endsWith('.json')) {
			try {
				finalData = JSON.stringify(JSON.parse(data));
			} catch(e) {
				alert("Invalid JSON! Please fix syntax.");
				return;
			}
		}
		var fd=new FormData();
		fd.append("file",new Blob([finalData],{type:"text/plain"}),filename);
		req.add("POST","/upload",fd,function(st,resp){
			if (st!=200) alert("ERROR "+st+": "+resp);
			else {
				alert("File saved successfully!");
				// Refresh file list after save
				if (window.fileTree) window.fileTree.refreshPath("/");
			}
		});
	}

	function httpGet(fn){
		if (!fn) return;
		req.add("GET", "/edit", { func:"edit", path:fn }, function(st, resp) {
			gId("preview").style.display="none";
			gId("editor").style.display="flex";
			if (st==200) {
				// Pretty-print JSON files for editing
				if (fn.toLowerCase().endsWith('.json')) {
					try {
						if (fn.toLowerCase().includes('ledmap')) {
							setCurrentContent(prettyLedmap(resp));
						} else {
							setCurrentContent(JSON.stringify(JSON.parse(resp), null, 2));
						}
					} catch(e) {
						setCurrentContent(resp); // Fall back to raw content if JSON is invalid
					}
				} else {
					setCurrentContent(resp);
				}
			} else {
				setCurrentContent("");
			}
			currentFile = fn;
			updateEditorMode(); // Update editor mode after loading
		});
	}

	if (file) httpGet(file);

	var ed={
		save:function(){
			// Always use filename from text field
			var pathField = gId("filepath");
			var fn = pathField ? pathField.value : "";
			if (!fn) {
				alert("Please enter a filename!");
				return;
			}
			if (!fn.startsWith("/")) fn = "/" + fn;
			currentFile = fn; // Update current file
			httpPost(fn, getCurrentContent());
			httpGet(fn); // reload after save
		},
		loadText:function(fn){
			currentFile=fn;
			// Update filename in text field
			var pathField = gId("filepath");
			if (pathField && fn) {
				var filename = fn.startsWith("/") ? fn.substring(1) : fn;
				pathField.value = filename;
			}
			httpGet(fn);
		},
		clearEditor:function(){
			gId("preview").style.display="none";
			gId("editor").style.display="flex";
			setCurrentContent("");
			// Update filename in text field
			var pathField = gId("filepath");
			pathField.value = "";
			pathField.placeholder = "Filename to save";
			updateEditorMode();
		}
	};

	return ed;
}

function onBodyLoad(){
	var vars={};
	window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi,function(m,k,v){
		vars[decodeURIComponent(k)]=decodeURIComponent(v);
	});

	var editor=createEditor("editor",vars.file);
	var tree=createTree("tree",editor);
	window.fileTree = tree; // Store reference for file list refresh
	createTop("top",tree,editor);
}
</script>
</head>
<body onload="onBodyLoad()">
	<div id="loader"><div class="loader"></div></div>
	<div id="top"></div>
	<div id="tree"></div>
	<div id="editor"></div>
	<div id="preview"></div>
</body>
</html>