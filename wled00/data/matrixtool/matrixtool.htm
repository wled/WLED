<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="@dedehai" />
<link rel="shortcut icon" href="favicon.ico">
<title>WLED Matrix Tool</title>
<script src="omggif.js"></script>
<style>
@import url("style.css");
body {
  max-width: 800px;
  margin: 0 auto;
}
/* Header styles */
.hdr .title {
  font-size: 32px;
  font-weight: bold;
  color: #fff;
  padding-top: 20px;
}

/* rainbow text animation */
.hdr .rb {
  background: linear-gradient(to right, #ef5350, #f48fb1, #7e57c2, #2196f3, #26c6da, #43a047, #eeff41, #f9a825, #ff5722);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-size: 300% 200%;
  animation: rb 5s linear infinite;
  font-size: 42px;
}

/* Common container styles - consolidates imgGrid, canvasWrap, controls-row */
.canvasWrap, .controls-row {
  display: flex;
  gap: 10px;
  margin: 20px 0;
}
.imgGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 10px;
  margin: 20px 0;
  padding: 0 5px;
}
.imgItem {
  aspect-ratio: 1;
  border: 2px solid #555;
  border-radius: 4px;
  background-size: cover;
  background-position: center;
  cursor: pointer;
  transition: all 0.3s ease;
  image-rendering: pixelated;
}
.imgItem:hover {
  border-color: #09a;
}
.imgItem.loading {
  background: #222;
  display: flex;
  align-items: center;
  justify-content: center;
}
.imgItem.loading::before {
  content: "Loading...";
}
.canvasWrap {
  flex-direction: column;
  gap: 5px;
  align-items: center;
  width: 100%;
  margin: 0;
}
.controls-row {
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  margin: 15px 0;
}

.ctxMenu, .editor {
  border: 2px solid #555;
  border-radius: 8px;
  background: #333;
}


/* Context menu styles */
.ctxMenu {
  position: fixed;
  padding: 8px;
  z-index: 10000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  border-radius: 8px;
}
.ctxMenu button {
  display: block;
  width: 100%;
  text-align: left;
  background: #333;
  border: 0;
  color: #fff;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  margin-bottom: 5px;
  font-size: 14px;
}
.ctxMenu button:hover {
  background: #555;
}
.ctxMenu button:last-child {
  margin-bottom: 0;
}
.ctxMenu button.danger {
  color: #f44;
}

/* Editor styles */
.editor {
  display: none;
  margin: 20px 0;
  padding: 20px;
  background: #222;
}
.editor.active {
  display: block;
}

/* Common input styles - consolidates color, canvas, slider inputs */
input[type="color"], #cropCanvas, #pixelPreview {
  border: 2px solid #555;
  background: #333;
}
input[type="color"] {
  border: 0;
}
#cropCanvas {
  cursor: crosshair;
  max-width: 100%;
  border-radius: 8px;
}
#pixelPreview {
  image-rendering: pixelated;
  border-radius: 4px;
}

/* Common notification styles - consolidates toast and drop */
.toast, .drop {
  border-radius: 8px;
  transition: all 0.3s ease;
}
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #555;
  color: #fff;
  padding: 12px 20px;
  font-size: 14px;
  z-index: 9999;
  border: 2px solid #888;
}
.drop {
  border: 2px dashed #555;
  padding: 40px 20px;
  background: #2a2a2a;
  cursor: pointer;
  margin: 20px auto;
  max-width: 80%;
}
.drop:hover {
  border-color: #48a;
  background: #333;
}

/* Button style extensions - consolidated hover states */
button, .btn, button.sml {
  border: 2px solid #333;
}
button:hover, .btn:hover, button.sml:hover {
  border-color: #48a;
}

/* Common layout styles - consolidates size-controls, size-row, bg-color-row */
.size-controls, .size-row, .bg-color-row {
  display: flex;
  align-items: center;
  justify-content: center;
}
.size-controls {
  display: none;
  margin: 15px 0;
  flex-direction: column;
}
.size-controls.show {
  display: flex;
}
.size-row {
  gap: 20px;
  margin-bottom: 10px;
}
.bg-color-row {
  margin-bottom: 15px;
}

.size-col {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 5px;
  min-width: 80px;
}
.size-col label {
  margin-bottom: 0px;
  font-size: 16px;
  color: #ccc;
}

/* Common text styles - consolidates slider-container, preview-info, preview-container */
.slider-container, .preview-container, .preview-info {
  text-align: center;
}
.slider-container {
  margin-bottom: 5px;
}
.slider-container label, .preview-info {
  display: block;
  margin-bottom: 5px;
}
.preview-info {
  margin-bottom: 10px;
  font-size: 14px;
  color: #ccc;
}

.slider {
  width: 100%;
  max-width: 500px;
}
.canvas-container {
  width: 100%;
}

@keyframes spin{to{transform:rotate(360deg)}}
@keyframes rb{0%{background-position:0% 0}100%{background-position:200% 0}}
</style>
</head>
<body>
<div class="cont">
<div class="hdr">
<div class="title">WLED <span class="rb">MATRIX</span> TOOL</div>
</div>

<h3 style="margin-top:20px;padding-top:0;border-top:0">Target Segment</h3>
<div class="row">
<div class="col">
<select id="seg"><option value="0" data-w="16" data-h="16">Segment 0 (16x16)</option></select>
</div>
</div>

<h3>Images on Device</h3>
<div class="imgGrid" id="grid"></div>
<div style="text-align:center;margin:15px 0">
<button class="sml" id="pxmagicBtn" style="display:none"> </button>
</div>

<h3>Upload New Image</h3>

<div id="drop" class="drop">
<p>Drop image or click to select</p>
</div>
<input type="file" id="src" accept="image/*" style="display:none">

<div class="editor" id="editor">
<h3 style="margin-top:0;padding-top:0;border-top:0">Crop & Adjust Image</h3>

<div class="controls-row">
<button class="sml" id="matchAspect">Match Aspect Ratio</button>
<button class="sml" id="matchSize">Match Size (1:1)</button>
<button class="sml" id="fullSize">Full Size</button>
<button class="sml" id="resetCrop">Reset</button>
</div>

<div class="canvasWrap">
<div class="canvas-container">
<div class="slider-container">
<label>Zoom: </label>
<input type="range" id="zoom" min="0" max="100" value="0" class="slider">
</div>
<canvas id="cropCanvas" width="500" height="400"></canvas>
</div>

<div class="preview-container">
<div class="preview-info">Preview at target size</div>

<canvas id="pixelPreview" width="128"></canvas>

<div class="slider-container">
<label>Dark Pixel Cutoff</label>
<input type="range" id="blackThresh" min="0" max="255" value="0" class="slider">
<div class="bg-color-row">
<label for="bgCol" style="margin-right:10px">Background Color</label>
<input type="color" id="bgCol" value="#000000">
</div>
</div>

<div class="size-controls" id="sizeControls">
<div class="size-row">
<div class="size-col">
<label for="w">Width</label>
<input type="number" id="w" value="16" min="1" class="s">
</div>
<div class="size-col">
<label for="h">Height</label>
<input type="number" id="h" value="16" min="1" class="s">
</div>
</div>
</div>

</div>
</div>

<div class="row" style="margin-top:20px">
<div class="col">
<label for="fname">Filename</label>
<input type="text" id="fname" placeholder="image" maxlength="26">
<small>.gif will be added</small>
</div>
</div>
<button class="btn" id="upload">Convert & Upload to WLED</button>
</div>

<div style="text-align:center;margin:20px 0">
<button class="btn" onclick="window.location.href=wURL">Back to the controls</button>
<div id="ov"></div>
<div id="mem" style="display:none;font-size:12px;color:#aaa;text-align:center;margin-top:6px"></div>
<script>
const d=document,gId=i=>d.getElementById(i),cE=t=>d.createElement(t);
const canvas=gId('cropCanvas'),ctx=canvas.getContext('2d',{willReadFrequently:true});
const pixelCanvas=gId('pixelPreview'),pixelCtx=pixelCanvas.getContext('2d',{willReadFrequently:true});
let wURL='',selImg=null,selFile=null,cropImg=null,baseScale=1,imgScale=1,panX=0,panY=0;
let crop={x:50,y:50,w:200,h:150},dragging=false,dragHandle=null,offsetX=0,offsetY=0;
let panning=false,panStartX=0,panStartY=0,panOrigX=0,panOrigY=0;
let imageList=[];
let gifFrames=null,gifInfo=null,animationTimer=null;

(async()=>{
  const params=new URLSearchParams(window.location.search);
  wURL=`http://${params.get('host')||window.location.host}`;
  await checkPxmagic();
  await loadSegs();
  await loadImgs();
  await mem();
})();

function toast(m,t='success'){
  const el=cE('div');el.className='toast';el.textContent=m;
  if(t==='error')el.style.background='var(--eDark)';
  d.body.appendChild(el);setTimeout(()=>el.remove(),3000);
}
function show(){gId('ov').classList.add('loading');gId('ov').style.display='block';}
function hide(){gId('ov').classList.remove('loading');gId('ov').style.display='none';}

function loadSegs(){
  const sel=gId('seg');
  const cSel=sel.value; // Store current selection
  fetch(`${wURL}/json/state`)
    .then(r => r.json())
    .then(data => {
      sel.innerHTML='';
      if(data.seg){
        data.seg.forEach(({id,n,start,stop,startY,stopY,fx})=>{
          const segName = n || `Segment ${id}`;
          const displayName = fx === 53 ? `${segName} [Image]` : segName;
          const opt=new Option(displayName,id);
          opt.dataset.w=stop-start;
          opt.dataset.h=stopY-startY;
          opt.dataset.fx=fx||0;
          sel.add(opt);
        });
      }else sel.add(new Option('Segment 0',0));
      // restore selection if non zero
      if(cSel){ sel.value=cSel; }
      const s=sel.options[sel.selectedIndex];
      if(s){gId('w').value=s.dataset.w||16;gId('h').value=s.dataset.h||16;}
    })
    .catch(e => console.error(e));
}

// check if a segment already uses fx 53 (image), only one image can be active at a time
function getCurImgSeg(){
  const sel=gId('seg');
  for(let i=0;i<sel.options.length;i++){
    if(parseInt(sel.options[i].dataset.fx)===53){
      return parseInt(sel.options[i].value);
    }
  }
  return null;
}

gId('seg').onchange=e=>{
  const opt=e.target.selectedOptions[0];
  gId('w').value=opt.dataset.w;gId('h').value=opt.dataset.h;
  if(cropImg)drawCrop();
};

async function loadImgs(){
  try{
    const r=await fetch(`${wURL}/edit?list=/`),data=await r.json(),grid=gId('grid');
    const types=['gif','png','jpg','jpeg','bmp'];
    const imgs=data.filter(f=>types.includes(f.name.split('.').pop()?.toLowerCase()));
    const newImageList=imgs.map(f=>f.name.replace('/',''));
    const missingImages = newImageList.filter(name => !imageList.includes(name)); // Find missing images (new ones to add)
    
    if(imageList.length === 0) { 
      // First load - clear grid and load all
      grid.innerHTML='';
      imageList = [...newImageList];
      if(!imgs.length){
        grid.innerHTML='<div style="grid-column:1/-1;text-align:center;color:#aaa;padding:20px">No images found</div>';
        return;
      }
      await loadImgs2(imgs);
    } else if(missingImages.length > 0) {
      // Add only missing images
      const missingImgData = imgs.filter(f => missingImages.includes(f.name.replace('/','')));
      imageList = [...newImageList];
      await loadImgs2(missingImgData);
    }
    // If no missing images, do nothing (keep existing display)
    
  }catch(e){console.error(e);}
}

async function loadImgs2(imgs){
  const grid = gId('grid');
  // Load images sequentially
  for(const f of imgs){
    const name=f.name.replace('/',''),url=`${wURL}/${name}`;
    const isGif=name.toLowerCase().endsWith('.gif');
    const item=cE('div');item.className='imgItem loading';
    item.dataset.name=name;item.dataset.url=url;
    item.onclick=()=>{
      if(isGif) playImg(url,name);
      else showUnsupported(url,name);
    };
    item.oncontextmenu=e=>{e.preventDefault();selImg={name,url};showMenu(e.pageX,e.pageY);};
    grid.appendChild(item);
    await new Promise((resolve)=>{
      const img=new Image();
      img.onload=()=>{
        item.style.backgroundImage=`url(${url}?cb=${Date.now()})`;
        if(!isGif) item.style.border = "5px solid red";
        item.classList.remove('loading');
        resolve();
      };
      img.onerror=()=>{item.classList.remove('loading');item.style.background='#222';resolve();};
      img.src=url+'?cb='+Date.now();
    });
  }
}

function rmImg(imageName){
  // Remove from local list
  imageList = imageList.filter(name => name !== imageName);
  
  // Remove from DOM
  const grid = gId('grid');
  const items = grid.querySelectorAll('.imgItem');
  items.forEach(item => {
    if(item.dataset.name === imageName) {
      item.remove();
    }
  });
  
  // Show "no images" message if list is empty
  if(imageList.length === 0) {
    grid.innerHTML='<div style="grid-column:1/-1;text-align:center;color:#aaa;padding:20px">No images found</div>';
  }
}

// check if pxmagic.htm(.gz) exists on device, if not, show install option, otherwise link to it
async function checkPxmagic(){
  try{
    const r=await fetch(`${wURL}/edit?list=/`),data=await r.json();
    const hasPx=data.some(f=>f.name==="/pxmagic.htm"||f.name==="/pxmagic.htm.gz");
    const btn=gId('pxmagicBtn');
    btn.style.display='inline-block';
    if(hasPx){
      btn.innerHTML='Open PIXEL MAGIC TOOL';
      btn.onclick=()=>window.open(`${wURL}/pxmagic.htm`,'_blank');
    }else{
      btn.innerHTML='Install classic PIXEL MAGIC TOOL<br>(convert image to json preset)';
      btn.onclick=async()=>{
        if(!confirm('Download from GitHub?'))return;
        try{
          const f=await fetch("https://dedehai.github.io/pxmagic.htm.gz");
          if(!f.ok) throw new Error("Download failed "+f.status);
          const b=await f.blob(),fd=new FormData();
          fd.append("data",b,"pxmagic.htm.gz");
          const u=await fetch(wURL+"/upload",{method:"POST",body:fd});
          alert(u.ok?"PxMagic installed!":"Upload failed");
          checkPxmagic();
        }catch(e){alert("Error "+e.message);}
      };
    }
  }catch(e){console.error(e);}
}

async function mem(){
  try{
    const r = await fetch(`${wURL}/json/info`);
    const info = await r.json();
    if(info && info.fs){
      gId("mem").textContent = `by @dedehai | Memory: ${info.fs.u} KB / ${info.fs.t} KB`;
      gId("mem").style.display = "block";
    }
  }catch(e){
    console.error(e);
  }
}

gId('drop').onclick=()=>{gId('src').value='';gId('src').click();};
gId('drop').ondragover=e=>{e.preventDefault();gId('drop').classList.add('active');};
gId('drop').ondragleave=()=>gId('drop').classList.remove('active');
gId('drop').ondrop=e=>{e.preventDefault();gId('drop').classList.remove('active');gId('src').files=e.dataTransfer.files;handleFile();};
gId('src').onchange=handleFile;

function handleFile(){
  const file=gId('src').files[0];
  if(!file)return;
  selFile=file;
  gifInfo=null; // invalidate

  // Show size controls when image is loaded
  gId('sizeControls').classList.add('show');

  // Check if it's a GIF - if so, parse it
 if(file.type==='image/gif'){
  const reader=new FileReader();
  reader.onload=e=>{
    const arr=new Uint8Array(e.target.result);
    try{
      const gif=new GifReader(arr);
      gifInfo={width:gif.width,height:gif.height,numFrames:gif.numFrames()};
      gifFrames=[];
      // disposal methods 0=unspecified, 1=keep, 2=restore to background, 3=restore to previous
      const accumCanvas=cE('canvas'); // persistent canvas to build up frames
      accumCanvas.width=gif.width;
      accumCanvas.height=gif.height;
      const accumCtx=accumCanvas.getContext('2d', {willReadFrequently: true});
      let savedFrame=null; // For disposal method 3

      for(let i=0;i<gifInfo.numFrames;i++){
        const frameInfo=gif.frameInfo(i);
        const disposal=frameInfo.disposal||0;
        // for disposal 3, save state BEFORE drawing
        if(disposal===3){
          savedFrame=accumCtx.getImageData(0,0,gif.width,gif.height);
        }
        // decode current frame
        const tempPixels=new Uint8Array(gif.width*gif.height*4);
        gif.decodeAndBlitFrameRGBA(i,tempPixels);

        const tempCanvas=cE('canvas');
        tempCanvas.width=gif.width;
        tempCanvas.height=gif.height;
        const tempCtx=tempCanvas.getContext('2d');
        const tempImageData=new ImageData(new Uint8ClampedArray(tempPixels),gif.width,gif.height);
        tempCtx.putImageData(tempImageData,0,0);

        // draw frame onto accumulation canvas
        accumCtx.drawImage(tempCanvas,0,0);
        // store the complete frame for display
        const completeFrame=accumCtx.getImageData(0,0,gif.width,gif.height);
        gifFrames.push({
          pixels:new Uint8Array(completeFrame.data),
          delay:frameInfo.delay||10
        });

        if(disposal===2){
          accumCtx.clearRect(0,0,gif.width,gif.height); // clear to background
        }else if(disposal===3){
          // Restore to saved state (before this frame was drawn)
          if(savedFrame){
            accumCtx.putImageData(savedFrame,0,0);
          }
        }
        // disposal 0 or 1: keep frame (do nothing)
      }
      loadGifCanvas();
    }catch(err){
      toast('Failed to parse GIF, loading as static image','error');
      console.error(err);
      loadAsStaticImage(file);
    }
  };
  reader.readAsArrayBuffer(file);
  }else
  {
    // Non-GIF image - existing code
    const reader=new FileReader();
    reader.onload=e=>{
      cropImg=new Image();
      cropImg.onload=()=>{
        gifFrames=null;gifInfo=null;
        gId('editor').classList.add('active');
        gId('drop').innerHTML=`<p>Image loaded: ${file.name}<br><small>Drop another to replace</small></p>`;
        gId('fname').value=file.name.split('.')[0].substring(0,16);
        resetView();
        const canvas=gId('cropCanvas');
        crop.w=canvas.width*0.8;
        crop.h=canvas.height*0.8;
        crop.x=(canvas.width-crop.w)/2;
        crop.y=(canvas.height-crop.h)/2;
        clampCrop();drawCrop();
      };
      cropImg.src=e.target.result;
    };
    reader.readAsDataURL(file);
  }
}

function loadGifCanvas(){
  gId('editor').classList.add('active');
  gId('drop').innerHTML=`<p>Animated GIF loaded: ${selFile.name} (${gifInfo.numFrames} frames)<br><small>Drop another to replace</small></p>`;
  gId('fname').value=selFile.name.split('.')[0].substring(0,16);
  
  // Create an image from first frame for cropping
  const tempCanvas=cE('canvas');
  tempCanvas.width=gifInfo.width;
  tempCanvas.height=gifInfo.height;
  const tempCtx=tempCanvas.getContext('2d');
  const imageData=new ImageData(new Uint8ClampedArray(gifFrames[0].pixels),gifInfo.width,gifInfo.height);
  tempCtx.putImageData(imageData,0,0);
  
  cropImg=new Image();
  cropImg.onload=()=>{
    resetView();
    const canvas=gId('cropCanvas');
    crop.w=canvas.width*0.8;
    crop.h=canvas.height*0.8;
    crop.x=(canvas.width-crop.w)/2;
    crop.y=(canvas.height-crop.h)/2;
    clampCrop();
    startGifAnim();
  };
  cropImg.src=tempCanvas.toDataURL();
}

function startGifAnim(){
  if(animationTimer)clearInterval(animationTimer);
  if(!gifFrames||gifFrames.length<=1||!gifInfo){ // not an animated image
    drawCrop();
    return;
  }

  let frameIndex=0;
  const tempCanvas=cE('canvas');
  tempCanvas.width=gifInfo.width;
  tempCanvas.height=gifInfo.height;
  const tempCtx=tempCanvas.getContext('2d');

  const animate=()=>{
    // Each frame is now complete, just draw it
    const imageData=new ImageData(new Uint8ClampedArray(gifFrames[frameIndex].pixels),gifInfo.width,gifInfo.height);
    tempCtx.putImageData(imageData,0,0);
    cropImg.src=tempCanvas.toDataURL();

    frameIndex=(frameIndex+1)%gifFrames.length;
  };

  cropImg.onload=()=>drawCrop();
  animate();
  const avgDelay=gifFrames.reduce((sum,f)=>sum+f.delay,0)/gifFrames.length;
  animationTimer=setInterval(animate,Math.max(avgDelay*10,50));
}

function stopGifAnim(){
  if(animationTimer){
    clearInterval(animationTimer);
    animationTimer=null;
  }
}

function showUnsupported(url,name){
  const msg=`Image format not supported by WLED.\nPlease convert to GIF below or use the Pixel Magic Tool.`;
  alert(msg);
  fetch(url)
    .then(r=>r.blob())
    .then(blob=>{
      const file=new File([blob],name,{type:blob.type});
      const dt=new DataTransfer();
      dt.items.add(file);
      gId('src').files=dt.files;
      handleFile();
    })
    .catch(e=>toast('Failed to load image','error'));
}

gId('w').oninput=()=>{if(cropImg)drawCrop();};
gId('h').oninput=()=>{if(cropImg)drawCrop();};


function clampCrop(){
  const canvas=gId('cropCanvas');
  crop.w=Math.max(30,Math.min(crop.w,canvas.width));
  crop.h=Math.max(30,Math.min(crop.h,canvas.height));
  crop.x=Math.max(0,Math.min(crop.x,canvas.width-crop.w));
  crop.y=Math.max(0,Math.min(crop.y,canvas.height-crop.h));
}

function resetView(){
  const canvas=gId('cropCanvas');
  baseScale=Math.min(canvas.width/cropImg.width,canvas.height/cropImg.height);
  imgScale=baseScale;
  panX=(canvas.width-cropImg.width*imgScale)/2;
  panY=(canvas.height-cropImg.height*imgScale)/2;
}

gId('zoom').oninput=()=>{
  if(!cropImg)return;
  const t=gId('zoom').value/100,newScale=baseScale*Math.pow(30,t);
  const canvas=gId('cropCanvas'),cx=canvas.width/2,cy=canvas.height/2;
  const dx=cx-panX,dy=cy-panY,factor=newScale/imgScale;
  panX=cx-dx*factor;panY=cy-dy*factor;imgScale=newScale;
  clampCrop();drawCrop();
};

gId('bgCol').oninput=drawCrop;

gId('matchAspect').onclick=e=>{
  e.preventDefault();
  const ratio=+gId('w').value/+gId('h').value;
  crop.h=crop.w/ratio;clampCrop();drawCrop();
};

gId('matchSize').onclick=e=>{
  e.preventDefault();
  if(!cropImg)return;
  crop.w=+gId('w').value*imgScale;crop.h=+gId('h').value*imgScale;
  clampCrop();drawCrop();
};

gId('fullSize').onclick=e=>{
  e.preventDefault();
  if(!cropImg)return;
  const canvas=gId('cropCanvas');
  crop.x=0;crop.y=0;
  crop.w=canvas.width;crop.h=canvas.height;
  clampCrop();drawCrop();
};

gId('resetCrop').onclick=e=>{
  e.preventDefault();
  if(!cropImg)return;
  const canvas=gId('cropCanvas');
  crop.w=canvas.width*0.8;
  crop.h=canvas.height*0.8;
  crop.x=(canvas.width-crop.w)/2;
  crop.y=(canvas.height-crop.h)/2;
  clampCrop();drawCrop();
};

function getHandles(r){
  const s=40, o=s/2, ox=r.x-o, oy=r.y-o, ow=r.w+s, oh=r.h+s;
  return{
    nw:{x:ox,y:oy,w:s,h:s}, ne:{x:ox+ow-s,y:oy,w:s,h:s},
    sw:{x:ox,y:oy+oh-s,w:s,h:s}, se:{x:ox+ow-s,y:oy+oh-s,w:s,h:s},
    n:{x:ox+s/2,y:oy,w:ow-s,h:s}, s:{x:ox+s/2,y:oy+oh-s,w:ow-s,h:s},
    w:{x:ox,y:oy+s/2,w:s,h:oh-s}, e:{x:ox+ow-s,y:oy+s/2,w:s,h:oh-s}
  };
}

function hitHandle(mx,my){
  const h=getHandles(crop);
  for(const k in h){let r=h[k];if(mx>=r.x&&mx<=r.x+r.w&&my>=r.y&&my<=r.y+r.h)return k;}
  return null;
}

function getPos(e){
  const rect=canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width; // account for CSS scaling
  const scaleY = canvas.height / rect.height;
  if(e.touches){ // touch
    return {
      x:(e.touches[0].clientX-rect.left)*scaleX,
      y:(e.touches[0].clientY-rect.top)*scaleY
    };
    }else{ // mouse
    return {
      x:(e.clientX-rect.left)*scaleX,
      y:(e.clientY-rect.top)*scaleY
    };
  }
}

function startAction(mx,my){
  dragHandle=hitHandle(mx,my);
  if(dragHandle){dragging=true;return;}
  if(mx>crop.x&&mx<crop.x+crop.w&&my>crop.y&&my<crop.y+crop.h){
    dragging=true;dragHandle="move";offsetX=mx-crop.x;offsetY=my-crop.y;
  }else{
    panning=true;panStartX=mx;panStartY=my;panOrigX=panX;panOrigY=panY;
  }
}

function moveAction(mx,my){
  if(dragging){
    switch(dragHandle){
      case "move":crop.x=mx-offsetX;crop.y=my-offsetY;break;
      case "nw":crop.w+=(crop.x-mx);crop.h+=(crop.y-my);crop.x=mx;crop.y=my;break;
      case "ne":crop.w=mx-crop.x;crop.h+=(crop.y-my);crop.y=my;break;
      case "sw":crop.w+=(crop.x-mx);crop.x=mx;crop.h=my-crop.y;break;
      case "se":crop.w=mx-crop.x;crop.h=my-crop.y;break;
      case "n":crop.h+=(crop.y-my);crop.y=my;break;
      case "s":crop.h=my-crop.y;break;
      case "w":crop.w+=(crop.x-mx);crop.x=mx;break;
      case "e":crop.w=mx-crop.x;break;
    }
    clampCrop();drawCrop();
  }else if(panning){
    panX=panOrigX+(mx-panStartX);
    panY=panOrigY+(my-panStartY);
    clampCrop();drawCrop();
  }
}

function endAction(){
  dragging=false;dragHandle=null;panning=false;
}

// Mouse events
canvas.onmousedown=e=>{if(!cropImg)return;const {x,y}=getPos(e);startAction(x,y);};
canvas.onmousemove=e=>{if(!cropImg)return;const {x,y}=getPos(e);moveAction(x,y);};
canvas.onmouseup=endAction;

// Touch events
canvas.ontouchstart=e=>{
  if(!cropImg||e.touches.length!==1)return;
  e.preventDefault();
  const {x,y}=getPos(e);
  startAction(x,y);
};
canvas.ontouchmove=e=>{
  if(!cropImg||e.touches.length!==1)return;
  e.preventDefault();
  const {x,y}=getPos(e);
  moveAction(x,y);
};
canvas.ontouchend=e=>{
  e.preventDefault();
  endAction();
};
canvas.ontouchcancel=e=>{
  e.preventDefault();
  endAction();
};

function drawCrop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!cropImg)return;
  ctx.fillStyle=gId('bgCol').value;ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.imageSmoothingEnabled=false;
  ctx.drawImage(cropImg,0,0,cropImg.width,cropImg.height,panX,panY,cropImg.width*imgScale,cropImg.height*imgScale);
  // draw crop frame with shadow
  ctx.lineWidth = 3;
  ctx.setLineDash([6,4]);
  ctx.shadowColor = "#000"; // soft dark shadow
  ctx.shadowBlur = 2;
  ctx.strokeStyle = "#FFF"; // main dashed color
  ctx.beginPath();
  ctx.roundRect(crop.x, crop.y, crop.w, crop.h, 6);
  ctx.stroke();
  ctx.shadowColor = "#000F"; // disable shadow again by simply making it transparent
  updPrev();
}

gId('blackThresh').addEventListener('input', () => { updPrev(); });

function applyBlackTh(c){
  let t=+gId('blackThresh').value,
    d=c.getImageData(0,0,c.canvas.width,c.canvas.height),
    b=gId('bgCol').value.match(/\w\w/g).map(x=>parseInt(x,16)); // extract ["rr","gg","bb"]
  for(let i=0;i<d.data.length;i+=4)
    if(d.data[i]<t&&d.data[i+1]<t&&d.data[i+2]<t)
      d.data[i]=b[0],d.data[i+1]=b[1],d.data[i+2]=b[2];
  c.putImageData(d,0,0);
}

function updPrev(){
  if(!cropImg)return;
  let w=+gId('w').value,h=+gId('h').value;
  const prev=pixelCanvas,pctx=pixelCtx;
  prev.height=Math.round(prev.width*(h/w));
  pctx.imageSmoothingEnabled=false;pctx.fillStyle=gId('bgCol').value;
  pctx.fillRect(0,0,prev.width,prev.height);
  pctx.drawImage(cropImg,(crop.x-panX)/imgScale,(crop.y-panY)/imgScale,crop.w/imgScale,crop.h/imgScale,0,0,w,h);
  // remove very dark colors and set them to black
  applyBlackTh(pctx);
  pctx.drawImage(prev,0,0,w,h,0,0,prev.width,prev.height);
}

gId('upload').onclick=async()=>{
  if(!selFile){toast('Select an image','error');return;}
  const w=+gId('w').value,h=+gId('h').value,fname=gId('fname').value.trim()||'image';
  const filename=`${fname}.gif`;
  
  // Check if file already exists
  const isReplacing = imageList.includes(filename);
  if(imageList.includes(filename)){
    if(!confirm(`${filename} already exists. Do you want to overwrite it?`))return;
  }
  
  show();
  try{
    let fileToUpload;
    if(gifFrames){
      // Animated GIF - re-encode with cropped frames
      const w=+gId('w').value,h=+gId('h').value;
      const gifData=[];
      const gifWriter=new GifWriter(gifData,w,h,{loop:0});

      const tempCanvas=cE('canvas');
      tempCanvas.width=gifInfo.width;
      tempCanvas.height=gifInfo.height;
      const tempCtx=tempCanvas.getContext('2d');

      const cropCanvas=cE('canvas');
      cropCanvas.width=w;
      cropCanvas.height=h;
      const cropCtx=cropCanvas.getContext('2d');

      for(let i=0;i<gifFrames.length;i++){
        // Draw source frame
        const imageData=new ImageData(new Uint8ClampedArray(gifFrames[i].pixels),gifInfo.width,gifInfo.height);
        tempCtx.putImageData(imageData,0,0);
        // Crop and resize
        cropCtx.imageSmoothingEnabled=false;
        cropCtx.fillStyle=gId('bgCol').value;
        cropCtx.fillRect(0,0,w,h);
        cropCtx.drawImage(tempCanvas,(crop.x-panX)/imgScale,(crop.y-panY)/imgScale,crop.w/imgScale,crop.h/imgScale,0,0,w,h);

        applyBlackTh(cropCtx);
        const finalData=cropCtx.getImageData(0,0,w,h);
        let {indexed,palette}=quantize(finalData.data);
        palette=padPalette(palette);

        gifWriter.addFrame(0,0,w,h,indexed,{palette,delay:gifFrames[i].delay,disposal:2});
      }
      gifWriter.end();
      fileToUpload=new File([new Uint8Array(gifData)],filename,{type:'image/gif'});
    }else if(selFile.type==='image/gif'){
      fileToUpload=selFile;
    }else{
      if(!cropImg){toast('Image not loaded','error');hide();return;}
      let tmp=cE('canvas');tmp.width=w;tmp.height=h;
      let tctx=tmp.getContext('2d');tctx.imageSmoothingEnabled=false;
      tctx.fillStyle=gId('bgCol').value;tctx.fillRect(0,0,w,h);
      tctx.drawImage(cropImg,(crop.x-panX)/imgScale,(crop.y-panY)/imgScale,crop.w/imgScale,crop.h/imgScale,0,0,w,h);
      applyBlackTh(tctx, 150);
      const imgData=tctx.getImageData(0,0,w,h);
      let {indexed,palette}=quantize(imgData.data);
      palette=padPalette(palette);
      const gifData=[];
      const gifWriter=new window.GifWriter(gifData,w,h,{loop:0});
      gifWriter.addFrame(0,0,w,h,indexed,{palette});
      gifWriter.end();
      fileToUpload=new File([new Uint8Array(gifData)],filename,{type:'image/gif'});
    }
    const fd=new FormData();fd.append('file',fileToUpload,filename);
    const r=await fetch(`${wURL}/upload`,{method:'POST',body:fd});
    if(r.ok){
      toast(`${filename} uploaded`);
      if(isReplacing){
        rmImg(filename); // remove from list so it reloads
      }
      await loadImgs();
      gId('src').value='';  // Add this line to reset the input
      gId('drop').innerHTML='<p>Drop image or click to select</p>';
    }else toast('Upload failed','error');
  }catch(e){toast(`Error: ${e.message}`,'error');}
  finally{hide();}
};

function quantize(pixels){
  let bitMask=0xFF;
  while(true){
    const colorMap=new Map(),tempIndexed=new Uint8Array(pixels.length/4);
    const paletteArray=[];let exceeded=false;
    for(let i=0,idx=0;i<pixels.length;i+=4,idx++){
      const r=pixels[i]&bitMask,g=pixels[i+1]&bitMask,b=pixels[i+2]&bitMask;
      const key=`${r},${g},${b}`;
      if(!colorMap.has(key)){
        colorMap.set(key,colorMap.size);
        paletteArray.push((r<<16)|(g<<8)|b);
        if(colorMap.size>256){exceeded=true;break;}
      }
      tempIndexed[idx]=colorMap.get(key);
    }
    if(!exceeded)return{indexed:tempIndexed,palette:paletteArray};
    bitMask&=(bitMask<<1)&0xFF;
    if(bitMask===0)return{indexed:tempIndexed,palette:paletteArray.slice(0,256)};
  }
}

function padPalette(palette){
  let pow2=1;
  while(pow2<palette.length)pow2<<=1;
  while(palette.length<pow2)palette.push(palette[palette.length-1]);
  return palette;
}

async function playImg(url,name){
  const targetSeg=+gId('seg').value;
  const currentImgSeg=getCurImgSeg();

  if(currentImgSeg!==null && currentImgSeg!==targetSeg){
    if(!confirm(`Segment ${currentImgSeg} is currently displaying an image. Switch image display to segment ${targetSeg}?`))return;
  }

  show();
  try{
    const json={
      on:true,
      seg: currentImgSeg!==null && currentImgSeg!==targetSeg
        ? [{id:currentImgSeg,fx:0,n:""},{id:targetSeg,fx:53,frz:false,sx:128,n:name}] // reset old, set new
        : {id:targetSeg,fx:53,frz:false,sx:128,n:name} // only set new
    };
    const r=await fetch(`${wURL}/json/state`,{method:'POST',body:JSON.stringify(json)});
    const result=await r.json();
    if(result.success){
      toast(`Playing ${name}`);
      await loadSegs();
    }else toast('Failed to play','error');
  }catch(e){toast(`Error: ${e.message}`,'error');}
  finally{hide();}
}

function showMenu(x,y){
  closeMenu();
  const menu=cE('div');
  menu.className='ctxMenu';
  menu.style.left=x+'px';
  menu.style.top=y+'px';
  menu.innerHTML=`
    <button onclick="downloadImg()">Download</button>
    <button class="danger" onclick="deleteImg()">Delete</button>
    <button onclick="closeMenu()">Cancel</button>
  `;
  d.body.appendChild(menu);
  setTimeout(()=>{
    const closeHandler=e=>{
      if(!e.target.closest('.ctxMenu')){closeMenu();d.removeEventListener('click',closeHandler);}
    };
    d.addEventListener('click',closeHandler);
  },100);
}

function closeMenu(){d.querySelectorAll('.ctxMenu').forEach(m=>m.remove());}

async function downloadImg(){
  try{
    const r=await fetch(selImg.url),blob=await r.blob();
    const url=URL.createObjectURL(blob),a=cE('a');
    a.href=url;a.download=selImg.name;a.click();
    URL.revokeObjectURL(url);toast('Downloaded');
  }catch(e){toast('Download failed','error');}
  closeMenu();
}

async function deleteImg(){
  if(!confirm(`Delete ${selImg.name}?`))return;
  show();
  try{
    const fd=new FormData();fd.append('path',`/${selImg.name}`);
    const r=await fetch(`${wURL}/edit`,{method:'DELETE',body:fd});
    if(r.ok){
      toast('Deleted');
      rmImg(selImg.name);
    }
    else toast('Delete failed','error');
  }catch(e){toast('Delete failed','error');}
  finally{hide();}
  closeMenu();
}
</script>
</body>
</html>