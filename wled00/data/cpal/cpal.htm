<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <title>WLED Palette Editor</title>
  <script>
    var d = document;
    const $ = (e) => gId(e);
    const C = (t) => cE(t);
  </script>
  <script src="common.js"></script>
  <script src="iro.js"></script>
  <style>
	@import url("style.css");
    :root {
      --bg:#111; --fg:#ddd; --bd:#333;
      --pad:16px;         /* side padding aligning editor and previews */
      --maxw:820px;       /* max working width */
      --actw:120px;       /* fixed actions column width (align custom vs static) */
      --namew:16ch;       /* 2/3 of 24ch to reduce name width by ~30% */
    }
    button.sml { text-overflow: clip; }

    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--fg); font:14px/1.35 system-ui, Segoe UI, Arial, sans-serif; }

    .container {
      max-width: calc(var(--maxw) + 2*var(--pad));
      margin: 20px auto;
      padding: 0 var(--pad);
      display: flex; flex-direction: column; align-items: center;
    }

    header { text-align:center; margin-bottom:10px; width:100%; }
    header h1 { margin:0; font-size:20px; font-weight:600; }

    #pickerWrap { display:flex; justify-content:center; margin:8px 0 12px; width:100%; }

    .bar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; margin:8px 0 12px; width:100%; max-width:var(--maxw); padding:0 var(--pad); }
    .small { font-size:12px; opacity:0.85; }

    /* Editor gradient row */
    #editor { width:100%; display:flex; justify-content:center; }
    #gradWrap {
      position:relative; height:34px; width:100%; max-width:var(--maxw);
      border-radius:8px; border:1px solid var(--bd); padding:0 var(--pad); box-sizing:border-box;
    }
    #grad { height:100%; border-radius:6px; }

    /* Markers (50% wider -> 15px) */
    .mk { position:absolute; top:50%; transform:translate(-50%,-50%); width:15px; height:34px; border:4px solid #0008; border-radius:6px; background:#999; touch-action:none; }
    .mk.sel { outline:4px solid #0bf; border-color:#000; }
    .mk[data-lock="1"] { background:#666; }

    section { margin-top:18px; width:100%; }

    /* List rows kept simple with flex:
       Name (left, fixed 16ch) | Preview (center, flex-basis 50%) | Actions (right, fixed width)
       Names hide on narrow screens, preview grows to fill space.
    */
    .table { max-width:var(--maxw); width:100%; margin:0 auto; padding:0 var(--pad); }
    .list { display:flex; flex-direction:column; gap:8px; width:100%; }
    .row { display:flex; align-items:center; gap:10px; width:100%; }
    .name { flex:0 0 var(--namew); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; opacity:.95; }
    .preview { flex:1 1 50%; min-width:100px; height:26px; border-radius:6px; border:1px solid var(--bd); }
    .actions { flex:0 0 var(--actw); display:flex; gap:6px; justify-content:flex-end; width:var(--actw); }
    .actions.one > .btn { width:100%; }         /* single button fills actions width */
    .actions.two > .btn { flex:1 1 0; }         /* two buttons share same width as one */

    /* Responsive: hide names before touching buttons or preview */
    @media (max-width: 760px) {
      .name { display:none; }
      .preview { flex-basis: auto; } /* preview expands to fill freed space */
    }
    @media (max-width: 420px) { .btn { padding:5px 8px; } }
  </style>
</head>
<body>
  <div class="container">
    <header><h1>WLED Palette Editor</h1></header>

    <div id="pickerWrap"><div id="picker"></div></div>

    <div class="bar">
      <button id="btnDist" class="sml">&#x2B0C;Distribute</button>
      <button id="btnNew" class="sml">&#x2730;New</button>
	  <button id="btnDel" class="sml">&#x1F5D1;Delete Marker</button>
    </div>

    <div id="editor">
      <div id="gradWrap"><div id="grad"></div></div>
    </div>

    <section>
      <div>
        <b>Custom slots</b>
        <span id="memWarn" class="small" style="display:none; color: var(--warn)">Warning: Adding many custom palettes might cause stability issues, create <a href="/settings/sec#backup" style="color:#ff9900">backups</a> before proceeding.</span>
      </div>
      <div class="table">
        <div id="custom" class="list"></div>
      </div>
    </section>

    <section>
      <div class="hdr">
        <b>WLED palettes</b>
      </div>
      <div class="table">
        <div id="static" class="list"></div>
      </div>
    </section>

    <!-- Bottom bar to fetch external palettes from GitHub Pages -->
    <div class="bar" style="margin-bottom: 24px;">
      <button id="btnFetchExt" class="btn">Load more palettes from WLED GitHub</button>
    </div>
  </div>

  <script>
    // State
    let grad = $('grad'), wrap = $('gradWrap'), rect, w = 0, scale = 1, padL = 16;
    let sel = null, pk = null;
    let cpalc = 0, cpalm = 10, palNm = [], custom = [], statics = [];

    const SKIP_FIRST_STATIC = 8; // skip dynamic palettes at start like original

    // Geometry
    function recalc() {
      rect = wrap.getBoundingClientRect();
      const cs = getComputedStyle(wrap);
      padL = parseInt(cs.paddingLeft || 16, 10);
      const padR = parseInt(cs.paddingRight || 16, 10);
      w = rect.width - padL - padR;
      scale = w / 255;
      layout();
      draw();
    }
    function layout() {
      [...grad.querySelectorAll('.mk')].forEach(m => {
        m.style.left = (padL + (+m.dataset.t * scale)) + 'px';
      });
    }

    // Stops + draw
    function stops() {
      return [...grad.querySelectorAll('.mk')]
        .map(m => ({ t: +m.dataset.t, c: m.dataset.c, lock: m.dataset.lock === '1' }))
        .sort((a, b) => a.t - b.t);
    }
    function draw() {
      const s = stops();
      grad.style.background = 'linear-gradient(to right,' + s.map(x =>
        x.c + ' ' + Math.round(x.t * scale) + 'px'
      ).join(',') + ')';
    }

    // Utils
    function randomHex() { return '#' + (Math.random() * 0xFFFFFF << 0).toString(16).padStart(6, '0'); }

    // Marker ops
    function select(m) {
      if (sel) sel.classList.remove('sel');
      sel = m || null;
      if (sel) sel.classList.add('sel');
      if (pk && sel) pk.color.hexString = sel.dataset.c;
    }
    function canAddMarker() { return grad.querySelectorAll('.mk').length < 16; }
    function add(t, c, lock = false) {
      if (t < 0 || t > 255) return;
      if (!canAddMarker()) return;
      if (grad.querySelector('.mk[data-t="' + t + '"]')) return;
      const m = C('div');
      m.className = 'mk';
      m.dataset.t = t;
      m.dataset.c = c || randomHex();
      m.dataset.lock = lock ? '1' : '0';
      m.style.left = (padL + (t * scale)) + 'px';
      m.style.background = m.dataset.c;
      grad.appendChild(m);
      select(m);
      draw();
    }
    function deleteSelected() {
      if (!sel || sel.dataset.lock === '1') return;
      sel.remove(); select(null); draw();
    }
    function setSelectedColor(hex) {
      if (!sel) return;
      sel.dataset.c = hex; sel.style.background = hex; draw();
    }
    function distribute() {
      const s = stops(); if (s.length < 3) return;
      const inner = s.slice(1, -1);
      const step = Math.round(255 / (inner.length + 1));
      inner.forEach((p, i) => {
        const t = step * (i + 1);
        const m = [...grad.querySelectorAll('.mk')].find(x => +x.dataset.t === p.t && x.dataset.lock !== '1');
        if (m) { m.dataset.t = t; m.style.left = (padL + (t * scale)) + 'px'; }
      });
      draw();
    }

    // New random (4â€“6 handles total, endpoints fixed)
    function newRandomUpTo6() {
      grad.innerHTML = '';
      add(0, randomHex(), true);
      const total = Math.floor(Math.random() * 3) + 4; // 4..6
      const innerCount = Math.max(2, total - 2);
      const positions = new Set();
      while (positions.size < innerCount) positions.add(Math.floor(Math.random() * 254) + 1);
      [...positions].sort((a,b)=>a-b).forEach(t => add(t, randomHex(), false));
      add(255, randomHex(), true);
    }


    // Data conversion
    function toJSON() { return JSON.stringify({ palette: stops().flatMap(s => [s.t, s.c.slice(1)]) }); }
    function cssFromArr(arr) {
      let out = [];
      for (let i = 0; i < arr.length; i += 2) {
        const t = arr[i], v = arr[i + 1];
        if (typeof v === 'string') out.push('#' + v + ' ' + (t / 255 * 100) + '%');
        else { out.push(`rgba(${v},${arr[i + 2]},${arr[i + 3]},1) ${(t / 255 * 100)}%`); i += 2; }
      }
      return 'linear-gradient(to right,' + out.join(',') + ')';
    }
    function upload(slot) {
      const r = new XMLHttpRequest();
      const b = new Blob([toJSON()], { type: 'application/json' });
      const fd = new FormData();
      r.onload = () => { localStorage.removeItem('wledPalx'); location.href = '/'; };
      r.open('POST', '/upload');
      fd.append('data', b, '/palette' + slot + '.json');
      r.send(fd);
    }
    function isNewSlot(arr) {
      return Array.isArray(arr) && arr.length === 1 && arr[0] === 255; // check for simple, invalid palette
    }
    function loadArray(arr) {
      grad.innerHTML = '';
      for (let i = 0; i < arr.length; i += 2) {
        const t = arr[i], v = arr[i + 1];
        let hex;
        if (typeof v === 'string') hex = '#' + v;
        else { hex = '#' + ((v << 16) | (arr[i + 2] << 8) | arr[i + 3]).toString(16).padStart(6, '0'); i += 2; }
        add(t, hex, (t === 0 || t === 255));
      }
    }

    // Lists (Name | Preview | Actions)
    function buildLists() {
      const cDiv = $('custom'), sDiv = $('static');
      cDiv.innerHTML = ''; sDiv.innerHTML = '';
      const fragC = d.createDocumentFragment(), fragS = d.createDocumentFragment();

      custom.forEach((p, i) => {
        const row = C('div'); row.className = 'row';
        const name = C('div'); name.className = 'name'; name.textContent = 'Custom' + i;
        const preview = C('div'); preview.className = 'preview'; preview.style.backgroundImage = cssFromArr(p.palette);
        const actions = C('div'); actions.className = 'actions two';
        const save = C('button'); save.className = 'sml'; save.innerHTML = '&#x1F81C;'; save.onclick = () => upload(i); // save, leftarrow &#x1F81C;
        if(!isNewSlot(p.palette)) {
          const load = C('button'); load.className = 'sml'; load.innerHTML = '&#x270E;'; load.onclick = () => loadArray(p.palette); // &#x270E; pencil
        }
        else {
            const load = C('span'); // no "load" button for empty slots
        }
        actions.append(save, load); row.append(name, preview, actions); fragC.appendChild(row);
      });

      statics.forEach(o => {
        const k = Object.keys(o)[0];
        const row = C('div'); row.className = 'row';
        const name = C('div'); name.className = 'name'; name.textContent = o.name || ('Palette ' + k);
        const preview = C('div'); preview.className = 'preview'; preview.style.backgroundImage = cssFromArr(o[k]);
        const actions = C('div'); actions.className = 'actions one';
        const load = C('button'); load.className = 'sml'; load.innerHTML = ' &#x1F81D;'; load.onclick = () => loadArray(o[k]); //Load  &#x1F81D; or &#x21E7;
        actions.append(load); row.append(name, preview, actions); fragS.appendChild(row);
      });

      cDiv.appendChild(fragC);
      sDiv.appendChild(fragS);
      $('memWarn').style.display = (cpalc >= 10) ? 'inline' : 'none';
    }

    async function fetchCustom(n) {
      custom.length = 0;

      const run = async () => {
        for (let i = 0; i <= n; i++) {
          const res = await fetch(getURL('/palette' + i + '.json'), { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          custom.push(await res.json());
        }
        if (custom.length < cpalm) custom.push({ palette: [255] }); // push simple, invalid palette to show empty slot
        buildLists();
      };

      try {
        await run();
      } catch (e) {
        try {
          await run(); // one retry
        } catch (e2) {
          console.warn(e2);
        }
      }
    }

    // Converter: cpt-city JSON -> statics entries
    // Input item shape: { name, author, colors: [t0, "hex0", t1, "hex1", ...] }
    // Output entries are appended to "statics" so they render at the bottom of the Static palettes list.
    function convertCptCityToStatics(arr) {
      if (!Array.isArray(arr)) return [];
      const out = [];
      arr.forEach((p, idx) => {
        if (!p || !Array.isArray(p.colors)) return;
        const colors = p.colors.slice(); // keep as [t, "hex", ...]; cssFromArr/loadArray understand this
        // Ensure it ends at t=255; if not, duplicate last color at 255
        if (typeof colors[colors.length - 2] === 'number' && colors[colors.length - 2] !== 255) {
          const lastColor = colors[colors.length - 1];
          colors.push(255, lastColor);
        }
        out.push({ [`ext-${idx}`]: colors, name: p.name || `External ${idx}` });
      });
      return out;
    }

    // Fetch from https://{username}.github.io/palette_selection_cpt_city.json
    async function fetchCptCityFromGithubPages() {
      try {
        const url = `https://dedehai.github.io/palette_selection_cpt_city.json`;
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const converted = convertCptCityToStatics(data);
        if (!converted.length) { alert('No palettes found in file.'); return; }
        statics = statics.concat(converted);
        buildLists();
        // Scroll to bottom of static list to show newly added palettes
        setTimeout(() => {
          const sDiv = $('static');
          sDiv.lastElementChild?.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 0);
      } catch (e) {
        console.error(e);
        alert('Failed to fetch palettes. Please check the username and that the JSON file is accessible.');
      }
    }

    async function init() {
      getLoc();
      try {
        const info = await fetch(getURL('/json/info')).then(r => r.json());
        const names = await fetch(getURL('/json/pal')).then(r => r.json());
        palNm = names; cpalc = info.cpalcount; cpalm = info.cpalmax;
        fetchCustom(cpalc - 1);

        let cache; try { cache = JSON.parse(localStorage.getItem('wledPalx')); } catch {}
        if (cache && cache.p) {
          for (const k in cache.p) {
            if (+k > 255 - cpalm) { delete cache.p[k]; continue; }
            const arr = cache.p[k]; if (!Array.isArray(arr)) { delete cache.p[k]; continue; }
            if (arr[arr.length - 1][0] !== 255) { const tail = [...arr[arr.length - 1]]; tail[0] = 255; arr.push(tail); }
            cache.p[k].name = palNm[k];
          }
          statics = Object.entries(cache.p)
            .filter(([k]) => +k >= SKIP_FIRST_STATIC)
            .map(([k, v]) => ({ [k]: v.flat(), name: v.name }));
        }
      } catch (e) {}
      recalc();
      newRandomUpTo6();
    }

    // Events
    window.addEventListener('resize', recalc);

    wrap.addEventListener('click', (e) => {
      if (e.target !== wrap && e.target !== grad) return;
      const t = Math.round((e.clientX - (rect.left + padL)) / scale);
      if (!canAddMarker()) return;
      if (t === 0 || t === 255) return;
      add(Math.max(1, Math.min(254, t)), pk ? pk.color.hexString : undefined);
    });

    grad.addEventListener('pointerdown', (e) => {
      const m = e.target.closest('.mk'); if (!m) return;
      select(m);
      if (m.dataset.lock === '1') return;
      e.preventDefault();
      const move = (ev) => {
        let x = Math.round((ev.clientX - (rect.left + padL)) / scale);
        x = Math.max(1, Math.min(254, x));
        m.dataset.t = x; m.style.left = (padL + (x * scale)) + 'px'; draw();
      };
      const up = () => { d.removeEventListener('pointermove', move); d.removeEventListener('pointerup', up); };
      d.addEventListener('pointermove', move); d.addEventListener('pointerup', up, { once:true });
    });

    d.addEventListener('keydown', (e) => {
      if (!sel || sel.dataset.lock === '1') return;
      let t = +sel.dataset.t;
      if (e.key === 'ArrowLeft') t = Math.max(1, t - (e.shiftKey ? 8 : 1));
      else if (e.key === 'ArrowRight') t = Math.min(254, t + (e.shiftKey ? 8 : 1));
      else return;
      sel.dataset.t = t; sel.style.left = (padL + (t * scale)) + 'px'; draw(); e.preventDefault();
    });

    $('btnDist').onclick = distribute;
    $('btnDel').onclick = deleteSelected;
    $('btnNew').onclick = newRandomUpTo6;
    $('btnFetchExt').onclick = fetchCptCityFromGithubPages;

    window.addEventListener('load', () => {
      pk = new iro.ColorPicker('#picker', {
        width: 240,
        layout: [
          { component: iro.ui.Wheel },
          { component: iro.ui.Slider, options: { sliderType: 'value' } }
        ]
      });
      pk.on('color:change', (c) => setSelectedColor(c.hexString));
      init();
    });
  </script>
</body>

</html>